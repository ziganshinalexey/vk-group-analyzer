## Автосборщик конфигураций

### Предпосылки создания автоcборщика конфигураций

Большие приложения имеют сложную конфигурацию, что затрудняет ее понимание, переопределение отдельных параметров и добавление параметров локальных настроек, поэтому базовый конфигурационный файл делят на несколько файлов. В результате появляется большое количество конфигурационных файлов, которые нужно собирать в один файл. Можно подключать их вручную с помощью команды require в файле с базовой конфигурацией. Однако это неудобно и нередко приводит к ошибкам. Таким образом, появляется необходимость в создании автосборщика конфигураций.


### Какие цели решает автоcборщик конфигураций

Целью автосборщика конфигураций является объединение в один массив большого количества конфигурационных файлов.


### Жизненный цикл автосборщика конфигураций

Автосборщик конфигураций имеет следующий жизненный цикл:

1. Во входном скрипте (по умолчанию для веб-приложений это файл `www/index.php`, а для консольных приложений - файл `protected/yiic`) создается объект класса `Userstory\ComponentAutoconfig\components\web\Autoconfig` или `Userstory\ComponentAutoconfig\components\console\Autoconfig` соответственно. Для этого вызывается конструктор, который принимает два необязательных параметра:

    - `configPath` - строка, содержащая путь к директории с базовой конфигурацией (обычно это директория `protected/config`).
    - `cacheFile` - строка, содержащая имя файла с общей конфигурацией (обычно для веб-приложений это файл `web.php`, а для консольных приложений - файл `console.php`).

    Они инициализируют свойства `Userstory\ComponentAutoconfig\components\Autoconfig::configPath` и `Userstory\ComponentAutoconfig\components\Autoconfig::cacheFile` соответственно. Свойство `configPath` определяет путь к директории, в которой автосборщик будет искать соответствующие маскам конфигурационные файлы. Свойство `cacheFile` определяет имя файла, в который автосборщик будет сохранять или из которого будет извлекать массив с общей конфигурацией.

2. Во входном скрипте от объекта класса Autoconfig вызывается метод `Userstory\ComponentAutoconfig\components\Autoconfig::load()`, который принимает один обязательный и два необязательных параметра:

    - `baseConfig` - строка, содержащая полное имя файла с базовой конфигурацией.
    - `modules` - массив, содержащий конфигурации пользовательских модулей или имена классов, реализующих их получение.
    - `masks` - массив, содержащий маски файлов дополнительных конфигураций.

    Во входном скрипте для веб-приложений это выглядит следующим образом:

    ```php
    $config = (new Autoconfig())->load(__DIR__ . '/../protected/config/web.php');
    ```

3. Если приложение находится в продуктивном режиме и файл с общей конфигурацией существует, то метод load() сразу возвращает массив с общей конфигурацией. В этом случае автосборщик пропускает 4 и 5 шаги.

4. Метод load() последовательно добавляет в массив с общей конфигурацией:

    - конфигурации модулей 'Userstory'. При этом модуль должен содержать класс Autoconfig, который реализует интерфейс `Userstory\ComponentAutoconfig\components\AutoconfigInterface`. В данном классе должен быть реализован метод `Userstory\ComponentAutoconfig\components\AutoconfigInterface::getConfig()`. Или, если конфиги для консоли и веб-окружения разные, см. следующий пункт.
    - если модули реализуют интерфейсы `Userstory/ModuleAutoconfig/interfaces/web/AutoconfigInterface` или `Userstory/ModuleAutoconfig/interfaces/console/AutoconfigInterface`, то будут вызваны соответствующие методы `getWebConfig` или `getConsoleConfig` для загрузки специфичной конфигурации для веб-окружения и для консоли.
    - дополнительные конфигурации, то есть конфигурации, файлы которых соответствуют заданным маскам.
    - базовую конфигурацию, которая содержится в файле, имя которого было передано в параметре `baseConfig`,
    - конфигурации пользовательских модулей, конфигурации или классы которых были переданы в параметре `modules`. Данный параметр может содержать массив с конфигурациями пользовательских модулей или массив с именами классов, реализующих их получение.

5. Метод load() сохраняет массив с общей конфигурацией в файл (кэширует его) в директорию, путь к которой содержится в свойстве `cachePath` (по умолчанию это директория `protected/runtime`), и возвращает данный массив.

6. Во входном скрипте массив с общей конфигурацией, который возвращает метод load(), передается в качестве параметра в конструктор класса `yii\web\Application`.

    Во входном скрипте для веб-приложений это выглядит следующим образом:

    ```php
    (new yii\web\Application($config))->run();
    ```


### Использование автосборщика конфигураций

Вы можете добавить свою конфигурацию в общую конфигурацию одним из следующих способов:

1. Вручную добавить свою конфигурацию в файл с базовой конфигурацией (по умолчанию это файл `protected/config/web.php`) (не рекомендуется).

2. Создать конфигурационный файл в директории с базовой конфигурацией (по умолчанию это директория `protected/config`) и назвать конфигурационный файл в соответствии с заданными по умолчанию масками `*.global.php` или `*.local.php`.

3. Создать конфигурационный файл в директории с базовой конфигурацией, но назвать его не в соответствии с масками `*.global.php` или `*.local.php`.

    В этом случае вам придется:
    - во входном скрипте (по умолчанию для веб-приложений это файл `www/index.php`, а для консольных приложений - файл `protected/yiic`) создать массив с масками,
    - записать в данный массив маску, которой будет соответствовать ваш конфигурационный файл (если вы хотите, чтобы в общую конфигурацию были добавлены конфигурационные файлы, соответствующие маскам `*.global.php` или `*.local.php`, то вам придется записать в данный массив и их тоже),
    - передать данный массив в качестве третьего параметра в метод load().

    Например:

    ```php
    $customMasks = [
        '*.global.php',
        '*.local.php',
        '*.other.php',
    ];
    $config = (new Autoconfig())->load(__DIR__ . '/../protected/config/web.php', [], $customMasks);
    ```

    Используя третий параметр метода load(), вы можете изменить порядок добавления соответствующих маскам конфигурационных файлов или вовсе отказаться от них.

    Например:

    ```php
    $customMasks = [
        '*.other.php',
    ];
    $config = (new Autoconfig())->load(__DIR__ . '/../protected/config/web.php', [], $customMasks);
    ```

    В этом случае в общую конфигурацию будут добавлены конфигурации файлов, соответствующих маске `*.other.php`. Конфигурации остальных файлов (`*.global.php` и `*.local.php`) будут проигнорированы.

4. Создать файл Autoconfig в корневой директории вашего модуля. Объявить в данном файле класс Autoconfig, который должен реализовывать интерфейс web/AutoconfigInterface или console/AutoconfigInterface в зависимости от того, что требуется сконфигурировать. Реализовать в данном классе метод getWebConfig() или getConsoleConfig(), который должен возвращать массив с конфигурацией вашего модуля.

    Например:

    ```php
    namespace Userstory\ComponentAutoconfig;

    use Userstory\ComponentAutoconfig\components\web\AutoconfigInterface;

    class Autoconfig implements AutoconfigInterface
    {
        public static function getWebConfig ()
        {
            return require __DIR__ . '/config/module.config.php';
        }
    }
    ```

    Обратите внимание, что в этом случае имя пространства имен вашего модуля должно начинаться с подстроки 'Userstory'.

5. Если вы используете сторонний модуль или пространство имен вне 'Userstory', то вы должны сделать следующее. В директории данного модуля создать файл с произвольным именем. Объявить в данном файле класс с тем же именем, который будет реализовывать интерфейс web/AutoconfigInterface или console/AutoconfigInterface. Реализовать в данном классе метод getWebConfig() или getConsoleConfig().

    В этом случае вам придется:
    - во входном скрипте (по умолчанию для веб-приложений это файл `www/index.php`, а для консольных приложений - файл `protected/yiic`) создать массив с именами классов, реализующих получение массива с конфигурацией модуля,
    - записать в данный массив имя класса,
    - передать данный массив в качестве второго параметра в метод load().

    Например:

    ```php
    $customModules = [
        YourModule\YourComponent\YourAutoconfig::class,
    ];
    $config = (new Autoconfig())->load(__DIR__ . '/../protected/config/web.php', $customModules, []);
    ```

    Обратите внимание, что метод load() в качестве второго параметра вместо массива с именами классов может принимать массив с конфигурациями. Например:

    ```php
    $customModules = [
        YourModule\YourComponent\YourAutoconfig::getConfig(),
        [
            // конфигурация вашего модуля
        ],
    ];

    $config = (new Autoconfig())->load(__DIR__ . '/../protected/config/web.php', $customModules, []);
    ```


### Правила слияния конфигураций в общий массив

Правила слияния конфигураций в общий массив обусловлены использованием для этой цели метода `yii\helpers\ArrayHelper::merge()`.

Слияние конфигураций в общий массив выполняется в соответствии со следующими правилами:

1. Если два объединяемых массива имеют элементы с числовыми ключами, то:
    - в конец первого массива будут добавлены элементы второго массива,
    - ключи элементов обоих массивов будут сохранены (при условии, что они не равны, этот случай будет рассмотрен в следующем правиле).

    Пример:

    ```php
    $a = [
        0 => 'str1',
        4 => 'str2',
    ];
    $b = [
        1 => 'str3',
        2 => 'str4',
    ];

    $c = ArrayHelper::merge($a, $b);

    // Результат:
    $c = [
        0 => 'str1',
        4 => 'str2',
        1 => 'str3',
        2 => 'str4',
    ];
    ```

2. Если два объединяемых массива имеют элементы с одинаковыми числовыми ключами, то элементу второго массива будет присвоен числовой ключ, значение которого на единицу больше значения числового ключа последнего элемента первого массива.

    Пример 1:

    ```php
    $a = [
        0 => 'str1',
    ];
    $b = [
        0 => 'str2',
    ];

    $c = ArrayHelper::merge($a, $b);

    // Результат:
    $c = [
        0 => 'str1',
        1 => 'str2',
    ];
    ```

    Пример 2:

    ```php
    $a = [
        0 => 'str1',
        4 => 'str2',
    ];
    $b = [
        0 => 'str3',
        2 => 'str4',
    ];

    $c = ArrayHelper::merge($a, $b);

    // Результат:
    $c = [
        0 => 'str1',
        4 => 'str2',
        5 => 'str3',
        2 => 'str4',
    ];
    ```

3. Если два объединяемых массива имеют элементы с одинаковыми строковыми ключами, и значение по крайней мере одного из элементов не является массивом, то элемент второго массива перезапишет элемент первого массива.

    Пример 1:

    ```php
    $a = [
        'a' => 'str1',
    ];
    $b = [
        'a' => 'str2',
    ];

    $c = ArrayHelper::merge($a, $b);

    // Результат:
    $c = [
        'a' => 'str2',
    ];
    ```

    Пример 2:

    ```php
    $a = [
        'a' => [
            0 => 1,
        ],
    ];
    $b = [
        'a' => 'str2',
    ];

    $c = ArrayHelper::merge($a, $b);

    // Результат:
    $c = [
        'a' => 'str2',
    ];
    ```

4. Если два объединяемых массива имеют элементы с одинаковыми строковыми ключами, и значения обоих элементов являются массивами, то объединение этих элементов будет выполнено в соответствии с описанными выше правилами (в рекурсивном вызове).

    Пример 1:

    ```php
    $a = [
        'a' => [
            0 => 1,
        ],
    ];
    $b = [
        'a' => [
            0 => 2,
        ],
    ];

    $c = ArrayHelper::merge($a, $b);

    // Результат:
    $c = [
        'a' => [
            0 => 1,
            1 => 2,
        ],
    ];
    ```

    Пример 2:

    ```php
    $a = [
        'a' => [
            'b' => 1,
        ],
    ];
    $b = [
        'a' => [
            'b' => 2,
        ],
    ];

    $c = ArrayHelper::merge($a, $b);

    // Результат:
    $c = [
        'a' => [
            'b' => 2,
        ],
    ];
    ```


### Работа с конфигурацией в продуктивном режиме

Если при работе в продуктивном режиме (то есть когда константа `YII_DEBUG` не определена или равна false) вы изменили конфигурацию или окружение, то следует удалить файл с общей конфигурацией. По умолчанию файл с общей конфигурацией для веб-приложений это файл `protected/runtime/web.php`, а для консольных приложений - `protected/runtime/console.php`.
